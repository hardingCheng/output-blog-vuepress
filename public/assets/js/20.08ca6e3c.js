(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{592:function(t,e,r){"use strict";r.r(e);var s=r(6),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"vuerouter"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vuerouter"}},[t._v("#")]),t._v(" VueRouter")]),t._v(" "),r("h3",{attrs:{id:"vuerouter-路由钩子函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vuerouter-路由钩子函数"}},[t._v("#")]),t._v(" VueRouter 路由钩子函数")]),t._v(" "),r("div",{staticClass:"language-js line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[t._v("路由的钩子函数总结有 "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),t._v(" 个\n\n全局的路由钩子函数：beforeEach、afterEach\n\n单个的路由钩子函数：beforeEnter\n\n组件内的路由钩子函数：beforeRouteEnter、beforeRouteLeave、beforeRouteUpdate\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br"),r("span",{staticClass:"line-number"},[t._v("6")]),r("br"),r("span",{staticClass:"line-number"},[t._v("7")]),r("br")])]),r("h3",{attrs:{id:"vuerouter-的-router-和-route-的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vuerouter-的-router-和-route-的区别"}},[t._v("#")]),t._v(" VueRouter 的 router 和 route 的区别?")]),t._v(" "),r("ul",[r("li",[t._v("$route 对象\n"),r("ul",[r("li",[t._v("$route 对象表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query 对象等。")]),t._v(" "),r("li",[t._v('$route.path 字符串，对应当前路由的路径，总是解析为绝对路径，如"/foo/bar"。')]),t._v(" "),r("li",[t._v("$route.params 一个 key/value 对象，包含了 动态片段 和 全匹配片段，如果没有路由参数，就是一个空对象。")]),t._v(" "),r("li",[t._v("$route.query 一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有$route.query.user == 1,如果没有查询参数，则是个空对象。")]),t._v(" "),r("li",[t._v("$route.hash 当前路由的 hash 值 (不带#) ，如果没有 hash 值，则为空字符串。锚点*")]),t._v(" "),r("li",[t._v("$route.fullPath 完成解析后的 URL，包含查询参数和 hash 的完整路径。")]),t._v(" "),r("li",[t._v("$route.matched 数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。")]),t._v(" "),r("li",[t._v("$route.name 当前路径名字")]),t._v(" "),r("li",[t._v("$route.meta 路由元信息")]),t._v(" "),r("li",[t._v("路由钩子函数")])])]),t._v(" "),r("li",[t._v("$router 对象\n"),r("ul",[r("li",[t._v("$router 对象是全局路由的实例，是 router 构造方法的实例。")]),t._v(" "),r("li",[t._v("路由实例方法：\n"),r("ul",[r("li",[t._v("push\n"),r("ul",[r("li",[t._v("字符串 this.$router.push('home')")]),t._v(" "),r("li",[t._v("对象 this.$router.push({path:'home'})")]),t._v(" "),r("li",[t._v("命名的路由 this$router.push({name:'user',params:{userId:123}})")]),t._v(" "),r("li",[t._v("带查询参数，变成 register?plan=123this.$router.push({path:'register',query:{plan:'123'}})")])])]),t._v(" "),r("li",[t._v("go\n"),r("ul",[r("li",[t._v("页面路由跳转")]),t._v(" "),r("li",[t._v("前进或者后退 this.$router.go(-1) // 后退")])])]),t._v(" "),r("li",[t._v("replace\n"),r("ul",[r("li",[t._v("push 方法会向 history 栈添加一个新的记录，而 replace 方法是替换当前的页面，")]),t._v(" "),r("li",[t._v("不会向 history 栈添加一个新的记录")]),t._v(" "),r("li",[t._v("一般使用 replace 来做 404 页面")])])])])])])])]),t._v(" "),r("h3",{attrs:{id:"hash-路由和-history-路由实现原理说一下-history-模式和-hash-模式的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hash-路由和-history-路由实现原理说一下-history-模式和-hash-模式的区别"}},[t._v("#")]),t._v(" hash 路由和 history 路由实现原理说一下 (history 模式和 hash 模式的区别)")]),t._v(" "),r("ul",[r("li",[t._v("location.hash 的值实际就是 URL 中#后面的东西。")]),t._v(" "),r("li",[t._v("history 实际采用了 HTML5 中提供的 API 来实现，主要有 history.pushState()和 history.replaceState()。")]),t._v(" "),r("li",[t._v("hash 模式\n"),r("ul",[r("li",[t._v("location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。")]),t._v(" "),r("li",[t._v("可以为 hash 的改变添加监听事件")]),t._v(" "),r("li",[r("code",[t._v('window.addEventListener("hashchange", funcRef, false);')])]),t._v(" "),r("li",[t._v("每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了")])])]),t._v(" "),r("li",[t._v("history 模式\n"),r("ul",[r("li",[t._v("利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。")]),t._v(" "),r("li",[t._v("这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。")])])])]),t._v(" "),r("h3",{attrs:{id:"vuerouter-中路由方法-pushstate-和-replacestate-能否触发-popsate-事件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vuerouter-中路由方法-pushstate-和-replacestate-能否触发-popsate-事件"}},[t._v("#")]),t._v(" VueRouter 中路由方法 pushState 和 replaceState 能否触发 popSate 事件")]),t._v(" "),r("ul",[r("li",[t._v("不能")]),t._v(" "),r("li",[t._v("HTML5 新接口，可以改变网址(存在跨域限制)而不刷新页面，这个强大的特性后来用到了单页面应用")]),t._v(" "),r("li",[t._v("仅改变网址,网页不会真的跳转,也不会获取到新的内容,本质上网页还停留在原页面")])]),t._v(" "),r("div",{staticClass:"language-js line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[t._v("window"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("history"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("pushState")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" title"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" targetURL"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n@状态对象：传给目标路由的信息"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("可为空\n@页面标题：目前所有浏览器都不支持"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("填空字符串即可\n@可选url：目标url，不会检查url是否存在，且不能跨域。如不传该项"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("即给当前url添加data\n\nwindow"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("history"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("replaceState")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" title"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" targetURL"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n@类似于pushState"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("但是会直接替换掉当前url"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("而不会在history中留下记录\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br"),r("span",{staticClass:"line-number"},[t._v("6")]),r("br"),r("span",{staticClass:"line-number"},[t._v("7")]),r("br")])]),r("ul",[r("li",[t._v("popstate 事件会在点击后退、前进按钮(或调用 history.back()、history.forward()、history.go()方法)时触发")])]),t._v(" "),r("h3",{attrs:{id:"vuerouter路由钩子函数是什么-执行顺序是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vuerouter路由钩子函数是什么-执行顺序是什么"}},[t._v("#")]),t._v(" VueRouter路由钩子函数是什么 执行顺序是什么")]),t._v(" "),r("p",[t._v("路由钩子的执行流程, 钩子函数种类有:全局守卫、路由守卫、组件守卫。")]),t._v(" "),r("ul",[r("li",[t._v("完整的导航解析流程:\n"),r("ul",[r("li",[t._v("导航被触发。")]),t._v(" "),r("li",[t._v("在失活的组件里调用 beforeRouteLeave 守卫。")]),t._v(" "),r("li",[t._v("调用全局的 beforeEach 守卫。")]),t._v(" "),r("li",[t._v("在重用的组件里调用 beforeRouteUpdate 守卫。重用的组件。")]),t._v(" "),r("li",[t._v("在路由配置里调用 beforeEnter。")]),t._v(" "),r("li",[t._v("解析异步路由组件。")]),t._v(" "),r("li",[t._v("在被激活的组件里调用 beforeRouteEnter。")]),t._v(" "),r("li",[t._v("调用全局的 beforeResolve 守卫。")]),t._v(" "),r("li",[t._v("导航被确认。")]),t._v(" "),r("li",[t._v("调用全局的 afterEach 钩子。")]),t._v(" "),r("li",[t._v("触发 DOM 更新。")]),t._v(" "),r("li",[t._v("调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。")])])])]),t._v(" "),r("h3",{attrs:{id:"vuerouter跳转方式有哪些"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vuerouter跳转方式有哪些"}},[t._v("#")]),t._v(" VueRouter跳转方式有哪些")]),t._v(" "),r("ul",[r("li",[t._v("router.push(location, onComplete?, onAbort?)\n"),r("ul",[r("li",[t._v("想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。")])])]),t._v(" "),r("li",[t._v("router.replace(location, onComplete?, onAbort?)\n"),r("ul",[r("li",[t._v("跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。")])])]),t._v(" "),r("li",[t._v("router.go(n)\n"),r("ul",[r("li",[t._v("这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。")])])])]),t._v(" "),r("h3",{attrs:{id:"vuerouter-添加参数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vuerouter-添加参数"}},[t._v("#")]),t._v(" VueRouter 添加参数")]),t._v(" "),r("ul",[r("li",[t._v("VueRouter 传递参数\n"),r("ul",[r("li",[t._v("编程式的导航 router.push\n"),r("ul",[r("li",[t._v("this.$router.push({ name: 'news', params: { userId: 123 }})\n"),r("ul",[r("li",[t._v("命名路由搭配 params，刷新页面参数会丢失")])])]),t._v(" "),r("li",[t._v("this.$router.push({ path: '/news', query: { userId: 123 }});\n"),r("ul",[r("li",[t._v("查询参数搭配 query，刷新页面数据不会丢失")])])])])]),t._v(" "),r("li",[t._v("声明式的导航 "),r("code",[t._v("<router-link>")]),t._v(" "),r("ul",[r("li",[r("code",[t._v("<router-link :to=\"{ name: 'news', params: { userId: 1111}}\">click to news page</router-link>")])])])])])])]),t._v(" "),r("div",{staticClass:"language-js line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[t._v("有两种"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\nquery 和 params\n\nquery 和 params 的区别：\n\nparams 传参只能由 name 引入路由，如果写成 path 页面会显示 "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),t._v(" 报错。\nquery 传参的话可以使用 path 也可以使用 name 引入路由，不过建议使用 path 引入路由。\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br"),r("span",{staticClass:"line-number"},[t._v("6")]),r("br"),r("span",{staticClass:"line-number"},[t._v("7")]),r("br")])]),r("h3",{attrs:{id:"location-href-和-vuerouter-的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#location-href-和-vuerouter-的区别"}},[t._v("#")]),t._v(" location.href 和 VueRouter 的区别")]),t._v(" "),r("ul",[r("li",[t._v("vue-router 使用 pushState 进行路由更新，静态跳转，页面不会重新加载；location.href 会触发浏览器，页面重新加载一次")]),t._v(" "),r("li",[t._v("vue-router 使用 diff 算法，实现按需加载，减少 dom 操作")]),t._v(" "),r("li",[t._v("vue-router 是路由跳转或同一个页面跳转；location.href 是不同页面间跳转；")]),t._v(" "),r("li",[t._v("vue-router 是异步加载 this.$nextTick(()=>{获取 url})；location.href 是同步加载")])])])}),[],!1,null,null,null);e.default=a.exports}}]);